layout(local_size_x = 8, local_size_y = 8) in;


#include "./GlobalDataBuffer.glsl"
#include "./CreateRay.glsl"
#include "./RayTracer.glsl"
#include "./Atmosphere.glsl"
#define LIGHTS_SET 2
#define LIGHTS_BINDING 0
#include "./LightsBuffer.glsl"

layout(set = 3, binding = 0) uniform sampler2D gBufferNormal;
layout(set = 4, binding = 0) uniform sampler2D voxelPositionSampler;
layout(set = 5, binding = 0) uniform sampler2D voxelHitPositionSampler;
layout(set = 6, binding = 0, rgba32f) uniform image2D outputImage;

uint rngState;

vec3 sampleHemisphere(vec3 normal) {
    float u = RandomFloat01(rngState);// Replace with your random number generator
    float v = RandomFloat01(rngState);
    float theta = acos(sqrt(1.0 - u));
    float phi = 2.0 * 3.14159265359 * v;

    // Convert spherical coordinates to cartesian
    vec3 localDir = vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));

    // Transform local direction to world space using the normal
    vec3 tangent = normalize(cross(vec3(0.0, 1.0, 0.0), normal));
    vec3 bitangent = cross(normal, tangent);
    return normalize(localDir.x * tangent + localDir.y * bitangent + localDir.z * normal);
}

vec3 computeDiffuseIndirectLight(Ray ray, uint maxBounces, float bias) {
    vec3 indirectLight = vec3(0.0);// Accumulated indirect light
    vec3 throughput = vec3(1.0);// Tracks light contribution across bounces

    for (uint bounce = 0; bounce < maxBounces; ++bounce) {
        Hit hitData = traceAllTiles(ray);

        if (!hitData.anyHit) {
            break;
        }
        vec3 hitPos = hitData.hitPosition;
        VoxelMaterialData matData = unpackVoxel(hitData);
        vec3 hitNormal = matData.normal;
        vec3 albedo = matData.albedo;
        vec3 randomDir = RandomUnitVector(rngState);
        float NdotL = max(dot(hitNormal, randomDir), 0.0);
        vec3 bounceLight = albedo * NdotL;
        indirectLight += throughput * bounceLight;
        throughput *= albedo;
        ray.o = hitPos + hitNormal;
        ray.d = randomDir;
    }

    return indirectLight;
}

void main() {
    vec2 outImageSize = imageSize(outputImage);
    vec2 texCoords = vec2(gl_GlobalInvocationID.xy) / outImageSize;
    vec4 hitPosition = texture(voxelHitPositionSampler, texCoords);
    if (hitPosition.a == 0){
        return;
    }
    vec4 finalColor = vec4(0, 0, 0, 1);
    vec3 voxelPosition = texture(voxelPositionSampler, texCoords).rgb;
    rngState = uint(round(rand(voxelPosition) * 100) + globalData.frameCount);
    float bias = max(.05, 1e-4 * length(hitPosition.xyz));
    vec3 normal = texture(gBufferNormal, texCoords).rgb;
    vec3 firstHitPos = hitPosition.xyz + normal * bias;

    { // ------ SHADOWS
        if (globalData.lightsQuantity > 0){
            for (int i = 0; i < globalData.lightsQuantity; ++i) {
                Light l = lightsBuffer.lights[i];
                if (length(l.position - hitPosition.xyz) < l.outerRadius) {
                    finalColor.a *= testLight(l.position, firstHitPos);
                }
            }
        }
        if (globalData.enabledSun){
            finalColor.a *= testLight(normalize(globalData.sunPosition) * 20, firstHitPos);
        }
    }

    { // ------ GLOBAL ILLUMINATION
        if (globalData.giBounces > 0) {
            for (uint i = 0; i < globalData.giSamplesPerPixel; i++) {
                vec3 randomDir = sampleHemisphere(normal);
                Ray ray = Ray(firstHitPos, randomDir, 1.0 / randomDir, vec3(0), false);
                vec3 indirectColor = computeDiffuseIndirectLight(ray, globalData.giBounces, 1);
                if (length(indirectColor) == 0 && globalData.enabledSun){
                    float NdotL = max(dot(normal, randomDir), 0.0);
                    indirectColor = calculate_sky_luminance_rgb(normalize(globalData.sunPosition), ray.d, 2.0f) * 0.05f * NdotL;
                }
                finalColor.rgb += indirectColor * 10;
            }
        }
    }

    ivec2 coord = ivec2(hashWorldSpaceCoord(texture(voxelPositionSampler, texCoords).rgb) * outImageSize);
    vec4 previousFrame = imageLoad(outputImage, coord);
    vec4 accumulatedResult = previousFrame * (1. - 1./float(globalData.frameCount+1)) + finalColor * 1./float(globalData.frameCount + 1);
    imageStore(outputImage, coord, accumulatedResult);
}