layout(local_size_x = 8, local_size_y = 8) in;

// SET 0
#include "./GlobalDataBuffer.glsl"
#include "./CreateRay.glsl"
// SET 1
#include "./RayTracer.glsl"
#include "./Atmosphere.glsl"

#define LIGHTS_SET 2
layout(set = 3, binding = 0) uniform sampler2D gBufferMaterialA;// Albedo
layout(set = 4, binding = 0) uniform sampler2D gBufferMaterialB;// Normal; Roughness
layout(set = 5, binding = 0) uniform sampler2D gBufferMaterialD;// Position
layout(set = 6, binding = 0, rgba32f) uniform image2D surfaceCacheImage;
layout(set = 7, binding = 0, rgba32f) uniform image2D globalIlluminationImage;

#include "./LightsBuffer.glsl"

uint rngState;
void computeLightContribution(in Light l, in vec3 surfaceAlbedo, in vec3 surfaceNormal, in vec3 surfacePosition, inout vec3 throughput, inout vec3 indirectLight){
    float bias = max(.05, 1e-4 * length(surfacePosition.xyz));
    vec3 localHitPosition = surfacePosition.xyz + surfaceNormal * bias;
    vec3 lightDir = normalize(l.position - localHitPosition);
    Ray ray = Ray(localHitPosition, lightDir, 1./lightDir);
    Hit hitData = traceAllTiles(ray);
    float lightDistance = length(l.position - localHitPosition);
    float hitDistance = length(hitData.hitPosition - localHitPosition);
    float localShadows = 1;
    if (hitData.anyHit && hitDistance < lightDistance) {
        localShadows = 0;
    }
    if (localShadows > 0){
        float NdotL = max(dot(surfaceNormal, lightDir), 0.0);
        vec3 lightColorContribution = l.color * surfaceAlbedo / PI;
        vec3 lightContribution = lightColorContribution * NdotL / length(l.position - localHitPosition);
        indirectLight += throughput * lightContribution;
        throughput *= lightColorContribution;
    }
}

void evaluateSurface(in Light sunLight, in vec3 albedo, bool isEmissive, in vec3 hitNormal, in vec3 currentPosition, inout vec3 throughput, inout vec3 indirectLight){
    ivec2 coord = ivec2(worldToSurfaceCacheHash(currentPosition) * vec2(globalData.giBufferWidth, globalData.giBufferHeight));

    vec3 lIndirect = vec3(0);
    vec3 lT = vec3(1);
    if (isEmissive){
        lIndirect += lT * albedo * globalData.giEmissiveFactor;
        lT *= albedo * globalData.giEmissiveFactor;
    } else {
        if (globalData.lightsQuantity > 0){
            for (int i = 0; i < globalData.lightsQuantity; ++i) {
                Light l = lightsBuffer.lights[i];
                computeLightContribution(l, albedo, hitNormal, currentPosition, lT, lIndirect);
            }
        }
        if (globalData.enabledSun){
            computeLightContribution(sunLight, albedo, hitNormal, currentPosition, lT, lIndirect);
        }
    }
    vec4 previousCacheData = imageLoad(surfaceCacheImage, coord);
    float accumulationCount = previousCacheData.a;
    vec3 accumulatedResult = previousCacheData.rgb * (1. - 1./accumulationCount) + lIndirect * 1./accumulationCount;
    imageStore(surfaceCacheImage, coord, vec4(accumulatedResult, accumulationCount + 1));
    indirectLight += accumulatedResult;
    throughput *= lT;
}

vec3 pathTraceScene(vec3 surfaceAlbedo, vec3 actualPosition, vec3 firstHitNormal, vec3 firstHitPos, float roughness, vec3 rayDir) {
    Light sunLight = Light(globalData.sunColor, globalData.sunPosition, -1, -1, -1);

    vec3 indirectLight = vec3(0.0); // Accumulated indirect light
    vec3 throughput = vec3(1.0); // Tracks light contribution across bounces
    vec3 randomDir;

    vec3 localNormal = firstHitNormal;
    vec3 localPosition = firstHitPos;
    float localRoughness = roughness;
    vec3 localRayDir = rayDir;
    for (uint j = 0; j < globalData.giBounces; j++){
        vec3 diffuseRayDir = normalize(localNormal + RandomUnitVector(rngState));
        vec3 specularRayDir = reflect(localRayDir, localNormal);

        specularRayDir = normalize(mix(specularRayDir, diffuseRayDir, localRoughness * localRoughness));
        localRayDir = mix(diffuseRayDir, specularRayDir, 1. - localRoughness);
        Ray ray = Ray(localPosition, localRayDir, 1.0 / localRayDir);
        Hit hitData = traceAllTiles(ray);
        if (!hitData.anyHit) {
            if (globalData.enabledSun){
                vec3 albedo = calculate_sky_luminance_rgb(normalize(globalData.sunPosition), ray.d, 2.0f) * 0.05f;
                evaluateSurface(sunLight, albedo, true, localNormal, localPosition, throughput, indirectLight);
            }
            break;
        }

        VoxelMaterialData matData = unpackVoxel(hitData);
        localNormal = matData.normal;
        localRoughness = .5;
        localPosition = hitData.hitPosition;
        evaluateSurface(sunLight, matData.albedo, matData.isEmissive, localNormal, localPosition, throughput, indirectLight);
    }

    return indirectLight / globalData.giBounces;
}

void main() {
    vec2 texCoords = vec2(gl_GlobalInvocationID.xy) / imageSize(globalIlluminationImage);
    vec4 materialD = texture(gBufferMaterialD, texCoords);
    if (materialD.a != 1.){
        return;
    }
    vec4 albedoEmissive = texture(gBufferMaterialA, texCoords);
    if (albedoEmissive.a != 0){
        return;
    }

    vec3 hitPosition = materialD.rgb;
    vec4 finalColor = vec4(0, 0, 0, 1);
    rngState = uint(uint(gl_GlobalInvocationID.x) * uint(1973) + uint(gl_GlobalInvocationID.y) * uint(9277) + uint(globalData.globalFrameCount) * uint(26699)) | uint(1);

    float bias = max(.05, 1e-4 * length(hitPosition.xyz));
    vec4 normalRoughness = texture(gBufferMaterialB, texCoords);
    vec3 normal = normalRoughness.rgb;
    vec3 currentPosition = hitPosition.xyz + normal * bias;

    vec4 previousFrame = imageLoad(globalIlluminationImage, ivec2(gl_GlobalInvocationID.xy));
    float accumulationCount = previousFrame.a;

    vec3 rayDir = createRay(texCoords, globalData.invProj, globalData.invView);
    vec3 currentFrame = pathTraceScene(albedoEmissive.rgb, hitPosition.xyz, normal, currentPosition, normalRoughness.a, rayDir);
    vec3 accumulatedResult = previousFrame.rgb * (1. - 1./accumulationCount) + currentFrame * 1./accumulationCount;


    imageStore(globalIlluminationImage, ivec2(gl_GlobalInvocationID.xy), vec4(accumulatedResult, accumulationCount + 1));
}