layout(local_size_x = 8, local_size_y = 8) in;


#include "./GlobalDataBuffer.glsl"
#include "./CreateRay.glsl"
#include "./RayTracer.glsl"
#include "./Atmosphere.glsl"
#define LIGHTS_SET 2
#define LIGHTS_BINDING 0
#include "./LightsBuffer.glsl"

layout(set = 3, binding = 0) uniform sampler2D gBufferNormal;
layout(set = 4, binding = 0, rgba32f) uniform image2D outputImage;
layout(set = 5, binding = 0) uniform sampler2D gBufferMaterialD;

uint rngState;

void computeLightContribution(in Light l, in vec3 albedo, in vec3 hitNormal, float bias, in vec3 currentPosition, inout vec3 throughput, inout vec3 indirectLight){
    vec3 firstHitPos = currentPosition.xyz + hitNormal * bias;
    vec3 lightDir = normalize(l.position - firstHitPos);
    vec3 rayDirection = normalize(l.position - firstHitPos);
    Ray ray = Ray(firstHitPos, rayDirection, 1./rayDirection);
    Hit hitData = traceAllTiles(ray);
    float lightDistance = length(l.position - firstHitPos);
    float hitDistance = length(hitData.hitPosition - firstHitPos);
    float shadows = 1;
    if (hitData.anyHit && hitDistance < lightDistance) {
        shadows = clamp(1 / lightDistance, 0, 1);
    }
    if (shadows > 0){
        float NdotL = max(dot(hitNormal, lightDir), 0.0);
        vec3 lightColorContribution = l.color * albedo;
        vec3 lightContribution = lightColorContribution * NdotL * shadows / length(l.position - firstHitPos);
        indirectLight += throughput * lightContribution;
        throughput *= lightColorContribution;
    }
}

vec3 computeDiffuseIndirectLight(vec3 firstHitNormal, vec3 firstHitPos) {
    vec3 indirectLight = vec3(0.0);// Accumulated indirect light
    vec3 throughput = vec3(1.0);// Tracks light contribution across bounces
    vec3 hitNormal = firstHitNormal;
    vec3 randomDir;

    Light sunLight = Light(globalData.sunColor, globalData.sunPosition, -1, -1, -1);
    for (uint i = 0; i < globalData.giSamplesPerPixel; i++) {
        randomDir = RandomUnitVector(rngState);
        Ray ray = Ray(firstHitPos, randomDir, 1.0 / randomDir);
        for (uint bounce = 0; bounce < globalData.giBounces; ++bounce) {
            Hit hitData = traceAllTiles(ray);
            if (!hitData.anyHit) {
                if (globalData.enabledSun){
                    float NdotL = max(dot(hitNormal, randomDir), 0.0);
                    vec3 albedo = calculate_sky_luminance_rgb(normalize(globalData.sunPosition), ray.d, 2.0f) * 0.05f;
                    vec3 bounceLight = albedo * NdotL;
                    indirectLight += throughput * bounceLight;
                    throughput *= albedo;
                }
                break;
            }

            vec3 currentPosition = hitData.hitPosition;
            VoxelMaterialData matData = unpackVoxel(hitData);
            float bias = max(.05, 1e-4 * length(currentPosition.xyz));
            hitNormal = matData.normal;
            vec3 albedo = matData.albedo;
            randomDir = RandomUnitVector(rngState);

            vec3 directLighting = vec3(0);
            float shadows = 1;
            if (globalData.lightsQuantity > 0){
                for (int i = 0; i < globalData.lightsQuantity; ++i) {
                    Light l = lightsBuffer.lights[i];
                    computeLightContribution(l, albedo, hitNormal, bias, currentPosition, throughput, indirectLight);
                }
            }
            if (globalData.enabledSun){
                computeLightContribution(sunLight, albedo, hitNormal, bias, currentPosition, throughput, indirectLight);
            }
            ray.o = currentPosition + hitNormal * bias;
            ray.d = randomDir;
        }
    }

    return indirectLight * globalData.giStrength;
}

void main() {
    vec2 texCoords = (vec2(gl_GlobalInvocationID.xy) * vec2(globalData.giFrameCount % 2 == 0 ? 2 : 1)) / vec2(globalData.bufferWidth, globalData.bufferHeight);
    vec4 materialD = texture(gBufferMaterialD, texCoords);
    if (materialD.a != 1.){
        return;
    }

    vec3 hitPosition = materialD.rgb;
    vec4 finalColor = vec4(0, 0, 0, 1);
    float voxelSize = float(globalData.giTileSubdivision);
    vec3 voxelPosition = round(hitPosition.xyz * voxelSize) / voxelSize;
    rngState = uint(round(rand(voxelPosition) * 100) + globalData.giFrameCount);
    float bias = max(.05, 1e-4 * length(hitPosition.xyz));
    vec3 normal = texture(gBufferNormal, texCoords).rgb;
    vec3 firstHitPos = hitPosition.xyz + normal * bias;

    if (globalData.giBounces > 0) {
        finalColor.rgb = computeDiffuseIndirectLight(normal, firstHitPos);
    }

    { // ------ SHADOWS
        if (globalData.lightsQuantity > 0){
            for (int i = 0; i < globalData.lightsQuantity; ++i) {
                Light l = lightsBuffer.lights[i];
                if (length(l.position - hitPosition.xyz) < l.outerRadius) {
                    finalColor.a *= testLight(l.position, firstHitPos);
                }
            }
        }
        if (globalData.enabledSun){
            finalColor.a *= testLight(normalize(globalData.sunPosition) * 20, firstHitPos);
        }
    }

    ivec2 coord = ivec2(hashWorldSpaceCoord(voxelPosition) * vec2(globalData.giBufferWidth, globalData.giBufferHeight));
    vec4 previousFrame = imageLoad(outputImage, coord);

    // TODO - Instead of global frame count, have a accumulation count per tile/hash
    vec4 accumulatedResult = previousFrame * (1. - 1./float(globalData.giFrameCount+1)) + finalColor * 1./float(globalData.giFrameCount + 1);
    imageStore(outputImage, coord, accumulatedResult);
}