layout(local_size_x = 8, local_size_y = 8) in;

#define LIGHTS_SET 4
#define VOLUMES_SET 3

#include "./GlobalDataBuffer.glsl"
#include "./LightsBuffer.glsl"
#include "./VolumesBuffer.glsl"
#include "./CreateRay.glsl"

layout(set = 1, binding = 0) uniform sampler2D gBufferPosition;
layout(set = 2, binding = 0, rgba32f) uniform image2D outputImage;


// Signed Distance Function for a cuboid
float sdfCuboid(vec3 p, vec3 b) {
    vec3 d = abs(p) - b;
    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);
}

float rayMarch(vec3 ro, vec3 rd, Volume volume, out vec3 hitPos) {
    float t = 0.0;
    const float maxDistance = 100.0;
    const float surfaceThreshold = 0.001;

    for (int i = 0; i < 256; i++) {
        hitPos = ro + rd * t;
        vec3 localPos = hitPos - volume.position;
        float dist = sdfCuboid(localPos, volume.dimensions * 0.5);

        if (dist < surfaceThreshold) {
            return t;
        }

        if (t > maxDistance) {
            break;
        }

        t += dist;
    }

    return -1.0; // No hit
}

void main() {
    vec2 texCoords = vec2(gl_GlobalInvocationID.xy) / imageSize(outputImage);
    vec4 worldPos = texture(gBufferPosition, texCoords);
    if (worldPos.a == 0.) {
        return;
    }
    vec3 rayDirection = createRay(texCoords, globalData.invProj, globalData.invView);
    vec3 rayOrigin = globalData.cameraWorldPosition;

    float closestDepth = 1e20;
    vec3 finalColor = vec3(0.0);

    for (int i = 0; i < MAX_VOLUMES; i++) {
        Volume volume = volumesBuffer.volumes[i];

        vec3 hitPos;
        float depth = rayMarch(rayOrigin, rayDirection, volume, hitPos);

        if (depth > 0.0 && depth < closestDepth) {
            closestDepth = depth;
            finalColor = volume.albedo * exp(-volume.density * depth);
        }
    }

    imageStore(outputImage, ivec2(gl_LocalInvocationID.xy), vec4(finalColor, 1));
}
