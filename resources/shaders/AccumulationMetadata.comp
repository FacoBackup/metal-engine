layout(local_size_x = 8, local_size_y = 8) in;

#include "./GlobalDataBuffer.glsl"

layout(set = 1, binding = 0, rgba32f) uniform image2D currentFrameImage;// Color + surface ID
layout(set = 1, binding = 1, rgba32f) uniform image2D volumetricCurrentFrame;
layout(set = 1, binding = 2, rgba32f) uniform image2D previousFrameImage;// Color + acuumulation count
layout(set = 1, binding = 3, rgba32f) uniform image2D previousFrameMetadataImage;// surface ID + position
layout(set = 1, binding = 4, rgba32f) uniform image2D currentPositions;

layout(push_constant) uniform Push {
    float diffWeight;
} push;

vec4 composite() {
    ivec2 fullResCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 fullResSize = imageSize(currentFrameImage);
    ivec2 halfResSize = imageSize(volumetricCurrentFrame);

    vec2 uv = vec2(fullResCoord) / vec2(fullResSize);

    vec2 halfTexelPos = uv * vec2(halfResSize) - 0.5;

    ivec2 texelBase = ivec2(floor(halfTexelPos));
    vec2 f = fract(halfTexelPos);

    texelBase = clamp(texelBase, ivec2(0), halfResSize - ivec2(1));
    ivec2 texelRight = min(texelBase + ivec2(1, 0), halfResSize - ivec2(1));
    ivec2 texelUp = min(texelBase + ivec2(0, 1), halfResSize - ivec2(1));
    ivec2 texelUpRight = min(texelBase + ivec2(1, 1), halfResSize - ivec2(1));

    vec4 c00 = imageLoad(volumetricCurrentFrame, texelBase);
    vec4 c10 = imageLoad(volumetricCurrentFrame, texelRight);
    vec4 c01 = imageLoad(volumetricCurrentFrame, texelUp);
    vec4 c11 = imageLoad(volumetricCurrentFrame, texelUpRight);

    vec4 volumetricColor = mix(mix(c00, c10, f.x), mix(c01, c11, f.x), f.y);

    vec4 fullResColor = imageLoad(currentFrameImage, fullResCoord);
    if (volumetricColor.a > 0.001){
        fullResColor.rgb = volumetricColor.rgb * volumetricColor.a + fullResColor.rgb * (1.0 - volumetricColor.a);
    }
    return fullResColor;
}

void main() {
    ivec2 coords =  ivec2(gl_GlobalInvocationID.xy);

    vec4 finalColor = composite();
    if (!globalData.enabledDenoiser){
        imageStore(currentFrameImage, coords, finalColor);
        return;
    }

    vec4 worldPos = imageLoad(currentPositions, coords);
    if (worldPos.a == 0){
        imageStore(previousFrameImage, coords, vec4(0, 0, 0, 1));
        imageStore(previousFrameMetadataImage, coords, vec4(0));
        return;
    }
    vec4 currentFrame = finalColor;// Color + surface ID
    vec4 previousFrameMetadata = imageLoad(previousFrameMetadataImage, coords);
    bool validHistory = (previousFrameMetadata.r == currentFrame.a) && (dot(previousFrameMetadata.gba, worldPos.rgb) > 0.95);

    if (!validHistory){
        imageStore(previousFrameImage, coords, vec4(currentFrame.rgb, 1));
    } else {
        vec4 prev = imageLoad(previousFrameImage, coords);
        float accumulationCount = prev.a + 1.0;

        // --- Adjust Accumulation Count Based on Color Change ---
        vec3 currentColor = currentFrame.rgb;
        vec3 colorVariance = vec3(0.0);

        for (int dx = -1; dx <= 1; ++dx) {
            for (int dy = -1; dy <= 1; ++dy) {
                ivec2 neighborCoord = coords + ivec2(dx, dy);
                neighborCoord = clamp(neighborCoord, ivec2(0), imageSize(currentFrameImage) - ivec2(1));

                vec3 neighborColor = imageLoad(currentFrameImage, neighborCoord).rgb;
                colorVariance += abs(currentColor - neighborColor);
            }
        }
        colorVariance /= 9.0;
        float averageColorVariance = (colorVariance.r + colorVariance.g + colorVariance.b) / 3.0;
        float varianceFactor = clamp(1.0 - averageColorVariance * push.diffWeight, 0.1, 1.0);
        accumulationCount *= varianceFactor;
        imageStore(previousFrameImage, coords, vec4(currentFrame.rgb, round(accumulationCount)));
    }
    imageStore(previousFrameMetadataImage, coords, vec4(currentFrame.a, worldPos.rgb));
}