layout(local_size_x = 8, local_size_y = 8) in;

#include "./GlobalDataBuffer.glsl"

#ifdef DEBUG
#include "./DebugFlags.glsl"
#endif


layout(set = 1, binding = 0, rgba32f) uniform image2D currentFrame;// Stores primitive ID in the A channel when denoiser is enabled
layout(set = 2, binding = 0, rgba32f) uniform image2D previousFrame;
layout(set = 3, binding = 0) uniform sampler2D gBufferNormal;

layout(push_constant) uniform Push {
    float  normalPhi, stepWidth;
} push;

// Gaussian function for weight calculation
float gaussian(float x, float sigma) {
    return exp(-0.5 * (x * x) / (sigma * sigma));
}

void main() {
    ivec2 coords =  ivec2(gl_GlobalInvocationID.xy);
    #ifdef DEBUG
    if (globalData.debugFlag != LIT && globalData.debugFlag != LIGHTING_ONLY){
        return;
    }
    #endif
    if (!globalData.enabledDenoiser){
        return;
    }

    vec2 samplerRes = imageSize(currentFrame);
    vec2 texCoords = vec2(coords)/samplerRes;
    vec3 centerNormal = texture(gBufferNormal, texCoords).xyz;
    vec4 centerColorAndId = imageLoad(currentFrame, coords);// Color and ID at the current fragment
    vec4 prev = imageLoad(previousFrame, coords);
    imageStore(previousFrame, coords, vec4(centerColorAndId.rgb, prev.a + 1));

    float centerId = centerColorAndId.a;

    float sigmaSpatial = push.stepWidth / samplerRes.x;// Spatial Gaussian spread
    vec3 finalColor = vec3(0);
    float totalWeight = 0.0;

    if(push.stepWidth > 0){
        for (int y = -int(push.stepWidth); y <= int(push.stepWidth); y++) {
            for (int x = -int(push.stepWidth); x <= int(push.stepWidth); x++) {
                vec2 offset = vec2(float(x), float(y)) / samplerRes;
                vec2 sampleUV = texCoords + offset;

                vec4 sampleColorAndId = imageLoad(currentFrame, ivec2(sampleUV * samplerRes));
                vec3 sampleColor = sampleColorAndId.rgb;
                float sampleId = sampleColorAndId.a;

                vec3 sampleNormal = texture(gBufferNormal, sampleUV).xyz;

                // Check if the primitive ID matches
                if (abs(sampleId - centerId) > 0.001) {
                    continue;
                }

                // Compute spatial and range weights
                float spatialWeight = gaussian(length(offset), sigmaSpatial);
                float rangeWeight = gaussian(length(sampleNormal - centerNormal), push.normalPhi);

                float weight = spatialWeight * rangeWeight;

                finalColor.rgb += sampleColor * weight;
                totalWeight += weight;
            }
        }
    }else {
        totalWeight = 1;
        finalColor = centerColorAndId.rgb;
    }

    finalColor.rgb /= totalWeight;
    imageStore(currentFrame, coords, vec4(finalColor.rgb, 1));
}